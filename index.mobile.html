<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Tetris Verbal — Móvil (beta)</title>
  <style>
    /* ======= Reset + Mobile-first layout ======= */
    :root {
      /* Dimensiones "virtuales" del tablero. La lógica usa estas medidas fijas (px). */
      --stage-w: 400; /* px */
      --stage-h: 550; /* px */
      --accent: #38bdf8;
      --accent-2: #a855f7;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; height: 100%; }
    body {
      font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: linear-gradient(140deg, #f8fafc, #e2e8f0 60%, #cbd5f5 100%);
      color: #0f172a;
      display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
      min-height: 100svh; /* iOS barras dinámicas */
    }

    /* ======= Pantalla de inicio ======= */
    #start-screen {
      position: fixed; inset: 0;
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.25), transparent 45%),
                  radial-gradient(circle at bottom, rgba(168, 85, 247, 0.25), transparent 50%),
                  rgba(2, 6, 23, 0.92);
      color: #fff;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: .75rem; text-align: center; z-index: 1000; padding: 1rem;
    }
    #start-screen::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(255,255,255,0.08), transparent 40%);
      pointer-events: none;
    }
    #start-card {
      position: relative;
      z-index: 1;
      width: min(420px, 92vw);
      padding: 1.6rem 1.5rem;
      border-radius: 18px;
      background: rgba(15, 23, 42, 0.78);
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
    }
    #start-screen h1 { margin: 0; font-size: 2rem; letter-spacing: .04em; }
    #start-screen p { margin: .2rem 0 .8rem; opacity: .85; }
    #start-screen .row { display: flex; gap: .5rem; align-items: center; justify-content: center; flex-wrap: wrap; }
    #start-screen select, #start-screen input {
      font-size: 1rem;
      padding: .35rem .5rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.8);
      color: #fff;
    }
    #start-screen button {
      margin-top: .5rem;
      padding: .65rem 1.3rem;
      font-size: 1.05rem;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #0f172a;
      box-shadow: 0 10px 24px rgba(56, 189, 248, 0.35);
      transition: transform .2s ease, box-shadow .2s ease;
    }
    #start-screen button:active { transform: translateY(1px); }
    #custom-options { display: none; margin-top: .5rem; }

    /* ======= HUD compacto ======= */
    #hud { width: 100%; max-width: 640px; padding: .5rem .75rem; display: flex; gap: .5rem; justify-content: space-between; align-items: center; }
    .chip {
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.6);
      padding: .35rem .6rem;
      border-radius: 999px;
      font-weight: 700;
      min-width: 96px;
      text-align: center;
      box-shadow: 0 10px 18px rgba(15, 23, 42, 0.12);
    }
    #btn-main {
      padding: .45rem .7rem;
      border: 1px solid rgba(148, 163, 184, 0.8);
      border-radius: 999px;
      background: #fff;
      box-shadow: 0 10px 18px rgba(15, 23, 42, 0.12);
    }

    /* ======= Stage escalado ======= */
    #shell { position: relative; touch-action: none; }
    #stage {
      position: relative;
      touch-action: none;
      width: calc(var(--stage-w) * 1px);
      height: calc(var(--stage-h) * 1px);
      background:
        radial-gradient(circle at top, rgba(56, 189, 248, 0.18), transparent 48%),
        linear-gradient(180deg, #f8fafc 0%, #e2e8f0 60%, #dbeafe 100%);
      border: 2px solid rgba(51, 65, 85, 0.55);
      border-radius: 14px;
      overflow: hidden;
      box-shadow: 0 22px 36px rgba(15, 23, 42, 0.18), inset 0 1px 0 rgba(255, 255, 255, 0.75);
    }
    #stage::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        linear-gradient(to right, rgba(148, 163, 184, 0.18) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(148, 163, 184, 0.18) 1px, transparent 1px);
      background-size: calc(100% / 4) calc(100% / 12);
      opacity: 0.55;
      pointer-events: none;
      z-index: 0;
    }
    #stage::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.05) 0%, rgba(15, 23, 42, 0.12) 70%, rgba(15, 23, 42, 0.18) 100%);
      pointer-events: none;
      z-index: 0;
    }
    #header-datos {
      position: absolute;
      top: 0; left: 0; right: 0;
      display: flex;
      justify-content: space-between;
      padding: 6px 8px;
      background: rgba(248, 250, 252, 0.95);
      border-bottom: 1px solid rgba(148, 163, 184, 0.6);
      font-size: 12px;
      font-weight: bold;
      z-index: 3;
      backdrop-filter: blur(6px);
    }
    .info-top { display: flex; flex-direction: column; align-items: center; flex: 1; padding: 2px; }
    .info-top span { font-size: 14px; font-weight: 600; margin-top: 2px; }
    #ventana-modo-top { border-radius: 999px; padding: 2px 6px; color: #fff; background: linear-gradient(135deg, #38bdf8, #a855f7); }

    /* ======= Opciones al pie (4 columnas) ======= */
    #conjugaciones {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      padding: 8px;
      background: linear-gradient(180deg, rgba(241, 245, 249, 0.98), rgba(226, 232, 240, 0.98));
      border-top: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 -10px 20px rgba(15, 23, 42, 0.12);
      z-index: 2;
      backdrop-filter: blur(6px);
    }
    .opcion-conjugacion {
      padding: 8px 6px;
      background: linear-gradient(135deg, #ffffff, #f8fafc);
      border: 1px solid rgba(148, 163, 184, 0.8);
      border-radius: 12px;
      font-weight: 800;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 0;
      overflow: hidden;
      box-shadow: 0 10px 18px rgba(15, 23, 42, 0.14);
    }
    .opcion-conjugacion .texto-ajustable { display: inline-block; transform-origin: center center; white-space: nowrap; }

    /* ======= Bloque ======= */
    .bloque {
      position: absolute;
      width: 80px;
      height: 40px;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #fff;
      font-weight: 800;
      text-align: center;
      line-height: 40px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.45);
      z-index: 4;
      box-shadow: 0 12px 18px rgba(22, 101, 52, 0.28), inset 0 -2px 6px rgba(15, 23, 42, 0.3);
    }
    .bloque.fijo {
      opacity: .85;
      background: linear-gradient(135deg, #ef4444, #b91c1c);
      border-color: rgba(255, 255, 255, 0.35);
      box-shadow: 0 8px 14px rgba(127, 29, 29, 0.4), inset 0 -2px 6px rgba(15, 23, 42, 0.35);
    }

    /* ======= Overlays ======= */
    #level-screen, #end-screen, #confirm-exit {
      position: fixed;
      inset: 0;
      background: rgba(2, 6, 23, 0.88);
      color: #fff;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 900;
      text-align: center;
      padding: 1rem;
    }
    #level-screen span { font-size: 3rem; font-weight: 900; }
    #end-screen .box,
    #level-screen .box {
      background: #0f172a;
      border: 1px solid rgba(148, 163, 184, 0.4);
      border-radius: 12px;
      padding: 1rem 1.2rem;
      max-width: 420px;
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.4);
    }
    #end-screen table { border-collapse: collapse; margin: .75rem auto 0; font-size: .95rem; }
    #end-screen th, #end-screen td { border: 1px solid #fff; padding: .35rem .6rem; }
    #level-diff { margin-top: .6rem; display: flex; flex-direction: column; gap: .35rem; align-items: center; }
    .diff-pill { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.25); padding: .35rem .6rem; border-radius: 999px; font-size: .95rem; }
    .end-actions { display: flex; gap: .6rem; justify-content: center; margin-top: .8rem; }
    .btn {
      padding: .6rem 1rem;
      font-size: 1rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: #111827;
      color: #fff;
    }

    /* Controles por gestos: barra removida para una UI minimalista */
  </style>
</head>
<body>
  <!-- PANTALLA DE INICIO -->
  <div id="start-screen">
    <div id="start-card">
      <h1>Tetris Verbal</h1>
      <p>Versión móvil (beta)</p>
      <div class="row">
        <label>Nivel:
          <select id="menu-nivel">
            <option value="easy">Fácil</option>
            <option value="medium">Medio</option>
            <option value="hard">Difícil</option>
            <option value="custom">Personalizado</option>
          </select>
        </label>
      </div>
      <div id="custom-options">
        <div class="row">
          <label>Modo:
            <select id="custom-modo">
              <option value="INDICATIVE">Indicativo</option>
              <option value="SUBJUNCTIVE">Subjuntivo</option>
            </select>
          </label>
          <label>Tiempo:
            <select id="custom-tiempo">
              <option value="PRESENT">Presente</option>
            </select>
          </label>
        </div>
        <div class="row" id="custom-subj-imp-wrapper" style="display:none;">
          <label>Var. imp. subj.:
            <select id="custom-subj-imp-var">
              <option value="SE">-se</option>
              <option value="RA">-ra</option>
            </select>
          </label>
        </div>
        <div class="row">
          <label>Verbos:
            <select id="custom-verbo-tipo">
              <option value="all">Todos</option>
              <option value="regular">Regulares</option>
              <option value="irregular">Irregulares</option>
            </select>
          </label>
          <label>Nº conj.:
            <input type="number" id="custom-count" min="5" max="100" value="20" />
          </label>
        </div>
      </div>
      <button id="start-btn">Iniciar</button>
    </div>
  </div>

  <!-- HUD superior -->
  <div id="hud" aria-hidden="true">
    <div class="chip">PUNTAJE: <span id="puntaje">000</span></div>
    <div class="chip">NIVEL: <span id="nivel">1</span></div>
    <button id="btn-main">Menú</button>
  </div>

  <!-- Escenario escalado -->
  <div id="shell">
    <div id="stage">
      <div id="header-datos">
        <div class="info-top" id="ventana-pronombre-top">PRONOMBRE<br><span>tú</span></div>
        <div class="info-top" id="ventana-tiempo-top">TIEMPO VERBAL<br><span>presente</span></div>
        <div class="info-top" id="ventana-modo-top">MODO<br><span>indicativo</span></div>
      </div>
      <div id="conjugaciones">
        <button class="opcion-conjugacion" type="button">---</button>
        <button class="opcion-conjugacion" type="button">---</button>
        <button class="opcion-conjugacion" type="button">---</button>
        <button class="opcion-conjugacion" type="button">---</button>
      </div>
    </div>
  </div>

  <!-- Overlays -->
  <div id="level-screen">
    <div class="box">
      <h2 id="level-title">NIVEL 1</h2>
      <div id="level-diff"></div>
    </div>
  </div>
  <div id="end-screen">
    <div class="box">
      <div id="end-summary"></div>
      <div class="end-actions">
        <button class="btn" id="btn-restart2">Reiniciar</button>
        <button class="btn" id="btn-mainmenu">Menú principal</button>
      </div>
    </div>
  </div>

  <div id="confirm-exit">
    <div class="box">
      <h2>¿Volver al menú?</h2>
      <p>Perderás el progreso de la partida actual.</p>
      <div class="end-actions">
        <button class="btn" id="btn-cancel-exit">Cancelar</button>
        <button class="btn" id="btn-confirm-exit">Sí, volver</button>
      </div>
    </div>
  </div>

    <script type="module">
    import SpanishVerbs from 'https://cdn.skypack.dev/spanish-verbs@3.4.0';
    window.SpanishVerbs = SpanishVerbs;

    // Escala el #stage a la pantalla móvil manteniendo el sistema de coordenadas 400x550
    function fitStage() {
      const shell = document.getElementById('shell');
      const stage = document.getElementById('stage');
      const hud   = document.getElementById('hud');
      const freeW = Math.min(window.innerWidth, 640); // límite ancho
      const usedH = (hud?.offsetHeight || 0) + 24; // margen superior/inferior // margencito
      const freeH = window.innerHeight - usedH;
      const sw = freeW / parseFloat(getComputedStyle(stage).width);
      const sh = freeH / parseFloat(getComputedStyle(stage).height);
      const s = Math.max(0.5, Math.min(sw, sh));
      window.__stageScale = s;
      shell.style.transform = `scale(${s})`;
      shell.style.transformOrigin = 'top center';
      shell.style.width = `${parseFloat(getComputedStyle(stage).width) * s}px`;
      shell.style.height = `${parseFloat(getComputedStyle(stage).height) * s}px`;
    }
    window.addEventListener('resize', fitStage);

    class GameMobile {
      constructor() {
        this.allIrregular = ["tener","ir","ser","hacer","decir","venir","estar","saber","querer","poder"];
        this.allRegular   = ["hablar","comer","vivir","estudiar","trabajar","caminar","cantar","amar","bailar","mirar"];
        this.pronombres   = ["yo","tú","él","nosotros","vosotros","ellos"];
        this.state = {
          config: {}, levelDefs: [], poolVerbos: [], poolIdx: 0,
          usedCount: 0, puntaje: 0, nivel: 1, fijos: [], velocidadY: 1
        };
      }
      init() {
        this.cacheDOM();
        this.setupListeners();
        this.updateCustomTiempoOptions();
        fitStage();
      }
      cacheDOM() {
        const get = id => document.getElementById(id);
        this.elems = {
          start: get('start-screen'),
          menuNivel: get('menu-nivel'),
          customOpts: get('custom-options'),
          startBtn: get('start-btn'),
          selModo: get('custom-modo'), selTiempo: get('custom-tiempo'), subjImpWrapper: get('custom-subj-imp-wrapper'), subjImpVar: get('custom-subj-imp-var'),
          selTipoVerbo: get('custom-verbo-tipo'), selCount: get('custom-count'),
          hud: get('hud'), puntaje: get('puntaje'), nivel: get('nivel'),
          shell: get('shell'), stage: get('stage'), header: get('header-datos'),
          conj: get('conjugaciones'),
          pronSpan: get('ventana-pronombre-top').querySelector('span'),
          tiempoSpan: get('ventana-tiempo-top').querySelector('span'),
          modoTop: get('ventana-modo-top'), modoSpan: get('ventana-modo-top').querySelector('span'),
          levelScr: get('level-screen'), endScr: get('end-screen'), endSummary: get('end-summary'),
          btnRestart: get('btn-restart2'), btnMainMenu: get('btn-mainmenu'), btnMain: get('btn-main'),
          exitConfirm: get('confirm-exit'), btnConfirmExit: get('btn-confirm-exit'), btnCancelExit: get('btn-cancel-exit')
        };
      }
      setText(node, txt) { if (node) node.textContent = txt; }

      setupListeners() {
        // Mostrar opciones personalizadas si corresponde
        this.elems.menuNivel.addEventListener('change', () => {
          const isCustom = this.elems.menuNivel.value === 'custom';
          this.elems.customOpts.style.display = isCustom ? 'block' : 'none';
          if (isCustom) this.updateCustomTiempoOptions();
        });
        // Iniciar juego
        this.elems.startBtn.addEventListener('click', () => this.handleStart());
        // Botón menú → confirmación de salida
        this.elems.btnMain.addEventListener('click', () => this.requestExitConfirm());
        if (this.elems.btnConfirmExit) this.elems.btnConfirmExit.addEventListener('click', () => this.exitConfirmChoice(true));
        if (this.elems.btnCancelExit)  this.elems.btnCancelExit.addEventListener('click', () => this.exitConfirmChoice(false));
        // Cambios en selects personalizados
        this.elems.selModo.addEventListener('change', () => this.updateCustomTiempoOptions());
        this.elems.selTiempo.addEventListener('change', () => this.updateSubjImpVisibility());
        // Tap en opciones → mover a columna y caída rápida
        Array.from(document.querySelectorAll('.opcion-conjugacion')).forEach((btn, i) => {
          const go = (ev) => { ev && ev.preventDefault(); if (!this.bloque) return; this.moveToColumn(i); this.dropFast = true; };
          btn.addEventListener('click', go);
          btn.addEventListener('touchend', go, { passive: false });
        });
        // Gestos en el stage (drag para mover, swipe abajo para caer, tap para alinear)
        const stage = this.elems.stage;
        let touch = null;
        const getTouch = (e) => {
          if (!touch) return null;
          for (const t of e.changedTouches) if (t.identifier === touch.id) return t;
          return null;
        };
        stage.addEventListener('touchstart', (e) => {
          if (!e.changedTouches.length) return;
          const t = e.changedTouches[0];
          touch = { id: t.identifier, startX: t.clientX, startY: t.clientY, lastX: t.clientX, lastY: t.clientY, moved: false };
        }, { passive: true });
        stage.addEventListener('touchmove', (e) => {
          const t = getTouch(e);
          if (!t || !this.bloque) return;
          const scale = window.__stageScale || 1;
          const dxStage = (t.clientX - touch.lastX) / scale;
          this.posX += dxStage;
          const maxX = this.elems.stage.clientWidth - this.blockW;
          this.posX = Math.max(0, Math.min(this.posX, maxX));
          this.updateBlock();
          touch.moved = true;
          touch.lastX = t.clientX; touch.lastY = t.clientY;
        }, { passive: true });
        stage.addEventListener('touchend', (e) => {
          const t = getTouch(e);
          if (!t) return;
          const dx = t.clientX - touch.startX;
          const dy = t.clientY - touch.startY;
          if (Math.abs(dy) > 40 && Math.abs(dy) > Math.abs(dx)) {
            this.dropFast = true;
          } else if (!touch.moved && this.bloque) {
            const rect = stage.getBoundingClientRect();
            const scale = window.__stageScale || 1;
            const localX = (t.clientX - rect.left) / scale;
            const colW = this.elems.stage.clientWidth / 4;
            const col = Math.floor(Math.max(0, Math.min(localX, this.elems.stage.clientWidth - 1)) / colW);
            this.moveToColumn(col);
            this.accel = true; setTimeout(() => this.accel = false, 200);
          }
          touch = null;
        });
        // Recalcular escala tras cambios de orientación
        window.addEventListener('orientationchange', () => setTimeout(fitStage, 300));
      }
      requestExitConfirm(){
        this._wasRunning = !!this.anim;
        if (this.levelTimer) { clearTimeout(this.levelTimer); this.levelTimer = null; }
        if (this.anim) { cancelAnimationFrame(this.anim); this.anim = null; }
        if (this.elems.levelScr) this.elems.levelScr.style.display = 'none';
        if (this.elems.endScr) this.elems.endScr.style.display = 'none';
        if (this.elems.exitConfirm) this.elems.exitConfirm.style.display = 'flex';
      }
      exitConfirmChoice(ok){
        if (this.elems.exitConfirm) this.elems.exitConfirm.style.display = 'none';
        if (ok) { this.returnToMenu(); }
        else if (this._wasRunning && this.bloque) { this.anim = requestAnimationFrame(() => this.animar()); }
      }

      updateCustomTiempoOptions() {
        const modo = this.elems.selModo.value;
        const sel = this.elems.selTiempo;
        const make = (v,t) => { const o = document.createElement('option'); o.value = v; o.textContent = t; return o; };
        sel.innerHTML = '';
        if (modo === 'SUBJUNCTIVE') {
          [ ['PRESENT','Presente'], ['PERFECT','Pretérito perfecto'], ['IMPERFECT','Pretérito imperfecto'], ['PLUPERFECT','Pretérito pluscuamperfecto'], ['FUTURE','Futuro'] ].forEach(([v,t]) => sel.appendChild(make(v,t)));
        } else {
          [ ['PRESENT','Presente'], ['IMPERFECT','Pretérito imperfecto'], ['PRETERITE','Pretérito indefinido'], ['FUTURE','Futuro'], ['PERFECT','Pretérito perfecto'], ['PLUPERFECT','Pretérito pluscuamperfecto'] ].forEach(([v,t]) => sel.appendChild(make(v,t)));
        }
        this.updateSubjImpVisibility();
      }
      updateSubjImpVisibility() {
        const isSubj = this.elems.selModo.value === 'SUBJUNCTIVE';
        const t = this.elems.selTiempo.value; const show = isSubj && (t === 'IMPERFECT' || t === 'PLUPERFECT');
        document.getElementById('custom-subj-imp-wrapper').style.display = show ? 'block' : 'none';
      }
      handleStart() {
        const mode = this.elems.menuNivel.value; this.state.config.mode = mode;
        if (mode === 'easy') this.setupEasy();
        else if (mode === 'medium') this.setupMedium();
        else if (mode === 'hard') this.setupHard();
        else this.setupCustom();
        this.elems.start.style.display = 'none';
        this.elems.hud.setAttribute('aria-hidden', 'false');
        this.resetGame();
      }
      setupEasy() {
        this.state.config.totalConj = 40;
        this.state.levelDefs = [
          { modo:'INDICATIVE', tiempo:'PRESENT', type:'regular', typoCount:0 },
          { modo:'INDICATIVE', tiempo:'PRESENT', type:'irregular', typoCount:1 },
          { modo:'INDICATIVE', tiempo:'IMPERFECT', type:'all', typoCount:0 },
          { modo:'INDICATIVE', tiempo:'PRETERITE', type:'all', typoCount:1 }
        ];
      }
      setupMedium() {
        this.state.config.totalConj = 40;
        this.state.levelDefs = [
          { modo:'INDICATIVE',tiempo:'PRESENT', type:'irregular', typoCount:2 },
          { modo:'CONDITIONAL',tiempo:'PRESENT', type:'all', typoCount:1 },
          { modo:'INDICATIVE',tiempo:'IMPERFECT', type:'irregular', typoCount:2 },
          { modo:'SUBJUNCTIVE',tiempo:'PRESENT', type:'irregular', typoCount:2 }
        ];
      }
      setupHard() {
        this.state.config.totalConj = 40; this.state.levelDefs = [ { modo:'RANDOM', tiempo:'RANDOM', type:'all', typoCount:2 } ];
      }
      setupCustom() {
        this.state.config.totalConj = parseInt(this.elems.selCount.value,10) || 20;
        const onlyIrreg = this.elems.selTipoVerbo.value === 'irregular';
        this.state.config.onlyIrreg = onlyIrreg;
        this.state.config.custom = { modo: this.elems.selModo.value, tiempo: this.elems.selTiempo.value };
        this.state.config.subjImpVar = (this.elems.subjImpVar && this.elems.subjImpVar.value) || 'SE';
        this.state.levelDefs = [ { modo: this.elems.selModo.value, tiempo: this.elems.selTiempo.value, type: onlyIrreg?'irregular':'all', typoCount:2 } ];
      }
      shuffle(a){ const arr=a.slice(); for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
      generarPool(){ const def=this.state.levelDefs[this.state.nivel-1]||this.state.levelDefs.at(-1); let src; if(def.type==='regular')src=this.allRegular; else if(def.type==='irregular')src=this.allIrregular; else src=[...this.allRegular,...this.allIrregular]; this.state.poolVerbos=this.shuffle(src); this.state.poolIdx=0; }

      // Compat con claves spanish-verbs
      safeGet(verbo,mk,tk,p){ const attempts=[`${mk}_${tk}`]; if(mk==='SUBJUNCTIVE'&&tk==='IMPERFECT') attempts.push('SUBJUNCTIVE_IMPERFECT_SE','SUBJUNCTIVE_IMPERFECT_RA','SUBJUNCTIVE_IMPERFECT'); if(mk==='SUBJUNCTIVE'&&tk==='PLUPERFECT') attempts.push('SUBJUNCTIVE_PLUPERFECT','SUBJUNCTIVE_PAST_PERFECT'); if(mk==='CONDITIONAL'&&tk==='PRESENT') attempts.push('CONDITIONAL','CONDITIONAL_PRESENT'); if(mk==='INDICATIVE'&&tk==='PLUPERFECT') attempts.push('INDICATIVE_PLUPERFECT','INDICATIVE_PAST_PERFECT');
        for(const key of [...new Set(attempts)]){ try{const r=SpanishVerbs.getConjugation(verbo,key,p); if(r) return {r,key};}catch{} } return {r:null,key:attempts[0]}; }
      stripAcc(s){ if(!s) return s; try{ return s.normalize('NFD').replace(/[̀-ͯ]/g,'').replace(/ñ/g,'n').replace(/Ñ/g,'N'); }catch{ return s; } }

      modeLabel(mk){
        if(mk==='SUBJUNCTIVE') return 'subjuntivo';
        if(mk==='CONDITIONAL') return 'condicional';
        if(mk==='RANDOM') return 'mixto';
        return 'indicativo';
      }
      timeLabel(mk, tk){
        const map={PRESENT:'presente', IMPERFECT:'pretérito imperfecto', PRETERITE:'pretérito indefinido', FUTURE:'futuro', PERFECT:'pretérito perfecto', PLUPERFECT:'pretérito pluscuamperfecto', RANDOM:'mixto'};
        if(mk==='SUBJUNCTIVE'){
          if(tk==='PERFECT') return 'perfecto (subj.)';
          if(tk==='FUTURE') return 'futuro (subj.)';
          if(tk==='PRESENT') return 'presente (subj.)';
          if(tk==='IMPERFECT') return 'imperfecto (subj.)';
          if(tk==='PLUPERFECT') return 'pluscuamperfecto (subj.)';
        }
        if(mk==='CONDITIONAL'){
          if(tk==='PRESENT') return 'condicional (simple)';
          if(tk==='PERFECT') return 'condicional perfecto';
        }
        return map[tk]||tk?.toLowerCase?.()||'';
      }

      generarDatos(){ if(this.state.poolIdx>=this.state.poolVerbos.length) this.generarPool(); const verbo=this.state.poolVerbos[this.state.poolIdx++]; const def=this.state.levelDefs[this.state.nivel-1]||this.state.levelDefs.at(-1);
        let mk=def.modo, tk=def.tiempo; if(mk==='RANDOM'){ const moods=['INDICATIVE','SUBJUNCTIVE','CONDITIONAL']; mk=moods[Math.floor(Math.random()*moods.length)]; }
        if(tk==='RANDOM'){
          const ind=['PRESENT','IMPERFECT','PRETERITE','FUTURE','PERFECT','PLUPERFECT']; const sub=['PRESENT','PERFECT','IMPERFECT','PLUPERFECT','FUTURE']; const cond=['PRESENT','PERFECT'];
          tk = mk==='SUBJUNCTIVE' ? sub[Math.floor(Math.random()*sub.length)] : mk==='CONDITIONAL' ? cond[Math.floor(Math.random()*cond.length)] : ind[Math.floor(Math.random()*ind.length)];
        }
        if(mk==='SUBJUNCTIVE'&&tk==='IMPERFECT'){ tk=(this.state.config.subjImpVar||'SE')==='RA'?'IMPERFECT_RA':'IMPERFECT_SE'; }
        if(mk==='SUBJUNCTIVE'&&tk==='PLUPERFECT'){ tk=(this.state.config.subjImpVar||'SE')==='RA'?'PLUPERFECT_RA':'PLUPERFECT_SE'; }
        const pIdx=Math.floor(Math.random()*6); const {r:correcta,key:keyUsed}=this.safeGet(verbo,mk,tk,pIdx); if(!correcta) return this.generarDatos();
        const modoLabel= mk==='SUBJUNCTIVE'?'subjuntivo': mk==='CONDITIONAL'?'condicional':'indicativo';
        const tkEff = keyUsed.replace(`${mk}_`, '');
        const map={PRESENT:'presente',IMPERFECT:'pretérito imperfecto',PRETERITE:'pretérito indefinido',FUTURE:'futuro',PERFECT:'pretérito perfecto',PLUPERFECT:'pretérito pluscuamperfecto'};
        const tiempoLabel=(()=>{ if(mk==='SUBJUNCTIVE'){ if(tkEff.startsWith('IMPERFECT')) return tkEff.includes('RA')?'imperfecto de subjuntivo (-ra)':'imperfecto de subjuntivo (-se)'; if(tkEff.startsWith('PLUPERFECT')) return tkEff.includes('RA')?'pluscuamperfecto de subj. (-ra)':'pluscuamperfecto de subj. (-se)'; if(tkEff==='PERFECT') return 'perfecto de subjuntivo'; if(tkEff==='FUTURE') return 'futuro de subjuntivo'; if(tkEff==='PRESENT') return 'presente de subjuntivo'; } if(mk==='CONDITIONAL'){ if(tkEff==='PRESENT') return 'condicional (simple)'; if(tkEff==='PERFECT') return 'condicional perfecto'; } return map[tkEff]||tkEff.toLowerCase(); })();
        const pronombre=this.pronombres[pIdx];
        // Distractores: otras personas del mismo tiempo + sin acentos + typo leve
        const set=new Set(); const add=v=>{ if(v&&v!==correcta) set.add(v); };
        const others=this.shuffle([0,1,2,3,4,5].filter(i=>i!==pIdx));
        for(const i of others){ try{ add(SpanishVerbs.getConjugation(verbo,keyUsed,i)); }catch{} if(set.size>=2) break; }
        const noAcc=this.stripAcc(correcta); if(noAcc!==correcta) add(noAcc);
        if(set.size<3){ // typo *muy* leve
          const i=Math.max(0,Math.min(correcta.length-1,2)); const alt=correcta.slice(0,i)+'e'+correcta.slice(i+1); add(alt);
        }
        const opciones=this.shuffle([...set, correcta]).slice(0,4);
        return { verbo, pronombre, modo:modoLabel, tiempo:tiempoLabel, correcta, opciones };
      }

      // ======= Juego =======
      moveToColumn(col){ const colW=this.elems.stage.clientWidth/4; this.posX=Math.round(col*colW + colW/2 - this.blockW/2); this.updateBlock(); }
      updateBlock(){ if(!this.bloque) return; const maxX=this.elems.stage.clientWidth - this.blockW; this.posX=Math.max(0,Math.min(this.posX,maxX)); this.bloque.style.transform=`translate3d(${this.posX}px,${this.posY}px,0)`; }

      crearBloque(){ this.dropFast=false; const data=this.generarDatos(); if(!data) return;
        this.setText(this.elems.pronSpan,data.pronombre); this.setText(this.elems.tiempoSpan,data.tiempo); this.setText(this.elems.modoSpan,data.modo);
        let color = '#4CAF50'; if (data.modo === 'subjuntivo') color = '#b71c1c'; else if (data.modo === 'condicional') color = '#2196F3'; this.elems.modoTop.style.backgroundColor=color;
        // opciones
        const btns=this.elems.conjBtns = Array.from(document.querySelectorAll('.opcion-conjugacion'));
        btns.forEach((btn,i)=>{ btn.innerHTML=''; const span=document.createElement('span'); span.className='texto-ajustable'; span.textContent=data.opciones[i]||'---'; btn.appendChild(span); btn.dataset.correcta = (data.opciones[i]===data.correcta);
          requestAnimationFrame(()=>{ const css=getComputedStyle(btn); const avail=btn.clientWidth - parseFloat(css.paddingLeft) - parseFloat(css.paddingRight); const txtW=span.scrollWidth; const scale=Math.min(1,avail/txtW); span.style.transform=`scale(${scale})`; span.style.margin='0 auto'; });
        });
        // bloque
        const bl=document.createElement('div'); bl.className='bloque'; bl.textContent=data.verbo; this.elems.stage.appendChild(bl); this.bloque=bl;
        this.blockW=80; this.blockH=40; bl.style.width=this.blockW+'px'; bl.style.height=this.blockH+'px'; bl.style.lineHeight=this.blockH+'px';
        this.posX = Math.floor((this.elems.stage.clientWidth - this.blockW)/2); this.posY= this.elems.header.clientHeight + 6;
        this.updateBlock(); this.anim = requestAnimationFrame(()=>this.animar());
      }
      animar(){ if(!this.bloque) return; const limitY = this.elems.stage.clientHeight - this.elems.conj.clientHeight - this.blockH - 4; // 4px colchón
        // check colisiones con fijos (básico)
        for(const f of this.state.fijos){ const x=f.offsetLeft, y=f.offsetTop; if(this.posX < x+this.blockW && this.posX+this.blockW > x && this.posY+this.blockH >= y && this.posY < y){ this.land(y - this.blockH); return; } }
        const speed = this.dropFast ? this.state.velocidadY*12 : this.accel ? this.state.velocidadY*4 : this.state.velocidadY;
        if(this.posY < limitY){ this.posY += speed; this.updateBlock(); this.anim=requestAnimationFrame(()=>this.animar()); } else { this.land(limitY); }
      }
      land(y){ this.posY=y; this.updateBlock(); this.verificarImpacto(); }
      verificarImpacto(){
        const colW = this.elems.stage.clientWidth/4;
        const cx = this.posX + this.blockW/2;
        const idx = Math.floor(cx/colW);
        const btn = document.querySelectorAll('.opcion-conjugacion')[idx];
        const statIdx = Math.max(0, (this.state.nivel||1) - 1);
        if(btn && btn.dataset.correcta==='true'){
          this.state.puntaje += 100;
          this.setText(this.elems.puntaje, String(this.state.puntaje).padStart(3,'0'));
          if (this.state.stats && this.state.stats[statIdx]) {
            this.state.stats[statIdx].ok++;
            this.state.stats[statIdx].puntos += 100;
          }
          this.bloque.remove();
          this.state.usedCount++;
          this.nextStep(true);
        } else {
          this.bloque.classList.add('fijo');
          this.bloque.style.transform='';
          this.bloque.style.left=this.posX+'px';
          this.bloque.style.top=this.posY+'px';
          this.state.fijos.push(this.bloque);
          if (this.state.stats && this.state.stats[statIdx]) {
            this.state.stats[statIdx].fail++;
          }
          this.state.usedCount++;
          if(this.posY <= this.elems.header.clientHeight + 6) return this.end(false);
          this.nextStep(false);
        }
      }
      nextStep(ok){ const total=this.state.config.totalConj; if(this.state.usedCount>=total) return this.end(true);
        // sin niveles complejos en móvil: solo marcador de nivel cada 10
        if(this.state.usedCount % 10 === 0){ this.state.nivel++; this.setText(this.elems.nivel, String(this.state.nivel)); this.showLevel(this.state.nivel); return; }
        this.bloque=null; cancelAnimationFrame(this.anim); this.crearBloque();
      }
      showLevel(n){
        const s = this.elems.levelScr;
        const titleEl = s.querySelector('#level-title') || s.querySelector('h2') || s.querySelector('span');
        const diffEl = s.querySelector('#level-diff');
        if (titleEl) titleEl.textContent = `NIVEL ${n}`;
        if (diffEl) {
          const defs = this.state.levelDefs;
          const curr = defs[Math.min(n-1, defs.length-1)] || {};
          const prev = defs[n-2] || null;
          const pills = [];
          if (!prev) {
            pills.push(`<div class="diff-pill">Modo: ${this.modeLabel(curr.modo||'INDICATIVE')}</div>`);
            pills.push(`<div class="diff-pill">Tiempo: ${this.timeLabel(curr.modo||'INDICATIVE', curr.tiempo||'PRESENT')}</div>`);
          } else {
            if ((curr.modo||'') !== (prev.modo||'')) pills.push(`<div class=\"diff-pill\">Modo: ${this.modeLabel(prev.modo)} → ${this.modeLabel(curr.modo)}</div>`);
            if ((curr.tiempo||'') !== (prev.tiempo||'')) pills.push(`<div class=\"diff-pill\">Tiempo: ${this.timeLabel(prev.modo, prev.tiempo)} → ${this.timeLabel(curr.modo, curr.tiempo)}</div>`);
            if (!pills.length) pills.push(`<div class=\"diff-pill\">Sin cambios respecto al nivel anterior</div>`);
          }
          diffEl.innerHTML = pills.join('');
        }
        s.style.display = 'flex';
        if (this.levelTimer) clearTimeout(this.levelTimer);
        this.levelTimer = setTimeout(() => {
          s.style.display = 'none';
          this.crearBloque();
        }, 1200);
      }

      resetGame(){
        if (this.levelTimer) { clearTimeout(this.levelTimer); this.levelTimer = null; }
        if (this.anim) { cancelAnimationFrame(this.anim); this.anim = null; }
        if (this.bloque) { this.bloque.remove(); this.bloque = null; }
        // Limpia cualquier bloque suelto/fijo en el stage
        this.elems.stage.querySelectorAll('.bloque').forEach(b => b.remove());
        this.setText(this.elems.puntaje,'000'); this.setText(this.elems.nivel,'1');
        this.state.puntaje=0; this.state.nivel=1; this.state.usedCount=0;
        this.state.fijos.forEach(b=>b.remove()); this.state.fijos.length=0;
        this.generarPool();
        // Inicializa estadísticas por nivel (10 conjugaciones por nivel)
        const levelsCount = Math.max(1, Math.ceil((this.state.config.totalConj||0) / 10));
        this.state.stats = Array.from({length: levelsCount}, (_,i) => {
          const def = this.state.levelDefs[Math.min(i, this.state.levelDefs.length-1)] || { modo:'INDICATIVE', tiempo:'PRESENT' };
          return { nivel: i+1, modo: this.modeLabel(def.modo), tiempo: this.timeLabel(def.modo, def.tiempo), ok: 0, fail: 0, puntos: 0 };
        });
        this.showLevel(1);
      }
      end(won){
        cancelAnimationFrame(this.anim);
        const sum=this.elems.endSummary;
        const total=this.state.puntaje;
        // Tabla por nivel
        let table='';
        if (Array.isArray(this.state.stats) && this.state.stats.length) {
          const rows = this.state.stats.map((s,i)=>`<tr><td>${i+1}</td><td>${s.modo}</td><td>${s.tiempo}</td><td>${s.ok}</td><td>${s.fail}</td><td>${s.puntos}</td></tr>`).join('');
          table = `<table><thead><tr><th>Nivel</th><th>Modo</th><th>Tiempo</th><th>Aciertos</th><th>Errores</th><th>Puntos</th></tr></thead><tbody>${rows}</tbody></table>`;
        }
        sum.innerHTML = `<h2>${won?'¡Felicitaciones!':'¡Fin del juego!'}</h2><p>Puntuación total: <strong>${total}</strong></p>${table}`;
        this.elems.endScr.style.display='flex';
        this.elems.btnRestart.onclick=()=>{ this.elems.endScr.style.display='none'; this.resetGame(); };
        this.elems.btnMainMenu.onclick=()=>this.returnToMenu();
      }
      returnToMenu(){
        if (this.levelTimer) { clearTimeout(this.levelTimer); this.levelTimer = null; }
        if (this.anim) { cancelAnimationFrame(this.anim); this.anim = null; }
        if (this.bloque) { this.bloque.remove(); this.bloque = null; }
        this.elems.stage.querySelectorAll('.bloque').forEach(b => b.remove());
        if (this.elems.exitConfirm) this.elems.exitConfirm.style.display='none';
        if (this.elems.endScr) this.elems.endScr.style.display='none';
        this.elems.start.style.display='flex';
        this.setText(this.elems.puntaje,'000'); this.setText(this.elems.nivel,'1');
        this.state.fijos.forEach(b=>b.remove()); this.state.fijos.length=0;
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      fitStage();
      const game = new GameMobile();
      game.init();
    });
  </script>
</body>
</html>
